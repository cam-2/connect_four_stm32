/*
 * GameLogic.C
 *
 *  Created on: Apr 17, 2025
 *      Author: Cameron Thomas
 */

#include "GameLogic.h"

static uint8_t sessionGameMode = NO_MODE_SELECTED;
static uint8_t playerTurn = YELLOW;
static uint8_t gameOver = FALSE;
static uint8_t coinDropped = FALSE;

static STMPE811_TouchData StaticTouchData;

extern TIM_HandleTypeDef htim2;

uint8_t gameBoard[NUM_ROWS][NUM_COLS];
uint8_t yellowWinCount = 0;
uint8_t redWinCount = 0;
uint32_t numSecondsElapsedInGame = 0;
coin_t gameCoin;


void setGameMode(uint8_t mode) {
	sessionGameMode = mode;
}


void resetBoard(void) {
	memset(gameBoard, 0, sizeof(gameBoard));
}


void resetCoinPos(void) {
	gameCoin.col = COIN_DEFAULT_COL;
	gameCoin.row = COIN_DEFAULT_ROW;
	gameCoin.yPos = COIN_DEFAULT_Y;
	coinDropped = FALSE;
}


void startNewGame(void) {
	resetBoard();
	gameOver = FALSE;
    numSecondsElapsedInGame = 0;
	playerTurn = YELLOW;
	playGame();
}


void incrementWinCount(void) {

	if(playerTurn == YELLOW) {
		yellowWinCount++;
	}
	else {
		redWinCount++;
	}
	gameOver = TRUE;
}


/* Checks which side of the screen is pressed, as well as if we are still
 * within the bounds of the board.
 * */
void checkIfUserMovedCoin(void) {
	if(returnTouchStateAndLocation(&StaticTouchData) == STMPE811_State_Pressed) {
		HAL_Delay(200);
		if(StaticTouchData.x > LCD_PIXEL_WIDTH / 2 && gameCoin.col > 0) {
			moveCoin(gameCoin.col - 1);
		}
		else if(StaticTouchData.x < LCD_PIXEL_WIDTH / 2 && gameCoin.col < 6) {
			moveCoin(gameCoin.col + 1);
		}
	}
}


void moveCoin(uint8_t col) {
	clearFloatingCoin((gameCoin.col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, gameCoin.yPos);
	gameCoin.col = col;

	if(playerTurn == YELLOW) {
		LCD_Display_Coin((gameCoin.col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_YELLOW);
	}
	else {
		LCD_Display_Coin((gameCoin.col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_RED);
	}
}


void placeCoin(uint8_t board[NUM_ROWS][NUM_COLS], uint8_t row, uint8_t col) {

	if(board[row][col]) {
		return;
	}

	board[row][col] = playerTurn;
	coinDropped = TRUE;

	if(playerTurn == YELLOW) {
		LCD_Display_Coin((col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, LCD_PIXEL_HEIGHT - BORDER_Y_OFFSET - (row + COIN_GAME_LOGIC_OFFSET) * BOARD_Y_OFFSET, LCD_COLOR_YELLOW);
	}
	else if(sessionGameMode == TWO_PLAYER_SELECT){
		LCD_Display_Coin((col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, LCD_PIXEL_HEIGHT - BORDER_Y_OFFSET - (row + COIN_GAME_LOGIC_OFFSET) * BOARD_Y_OFFSET, LCD_COLOR_RED);
	}

	return;
}


uint8_t canPlaceCoin(uint8_t board[NUM_ROWS][NUM_COLS], uint8_t col) {

	for(int row = 0; row < NUM_ROWS; row++) {
		if(!board[row][col]) {
			gameCoin.row = row;
			return TRUE;
		}
	}
	return FALSE;
}


uint8_t getScoreByDirection(uint8_t board[NUM_ROWS][NUM_COLS], uint8_t row, uint8_t col, uint8_t rowDelta, uint8_t colDelta, uint8_t player) {
	uint8_t score = 0;

    for (uint8_t count = 0; count < 4; count++) {
        if (row < NUM_ROWS && row >= 0 && col < NUM_COLS && col >= 0) {
            if (board[row][col] == player) {
                score++;
            }
        }
        else {
        	return score;
        }
        row += rowDelta;
        col += colDelta;
    };
    return score;
}


/* First check if theres a win condition by checking the last piece placed.
 * If no win condition, check for the case that a draw has occured,
 * (all pieces in column are full).
 * Otherwise, return false.
 */
uint8_t checkWinner(uint8_t board[NUM_ROWS][NUM_COLS], uint8_t row, uint8_t column, uint8_t player) {

	/* Horizontal check */
	for(col = 0; col < NUM_COLS - 3; col++) {
		for(row = 0; row < NUM_ROWS; row++) {
			if(board[row][col] == player && board[row][col + 1] == player && board[row][col + 2] == player && board[row][col + 3] == player) {
				return TRUE;
			}
		}
	}

	/* Vertical check */
	for(col = 0; col < NUM_COLS; col++) {
		for(row = 0; row < NUM_ROWS - 3; row++) {
			if(board[row][col] == player && board[row + 1][col] == player && board[row + 2][col] == player && board[row + 3][col] == player) {
				return TRUE;
			}
		}
	}

	/* Descending Diagonal check, from bottom and top of diagonal. */
	for(col = 0; col < NUM_COLS - 3; col++) {
		for(row = 0; row < NUM_ROWS - 3; row++) {
			if(board[row][col] == player && board[row + 1][col + 1] == player && board[row + 2][col + 2] == player && board[row + 3][col + 2] == player) {
				return TRUE;
			}
		}
	}

	/* Ascending Diagonal check, from bottom and top of diagonal. */
	for(col = 0; col < NUM_COLS - 3; col++) {
		for(row = 0; row < NUM_ROWS - 3; row++) {
			if(board[row][col] == player && board[row - 1][col + 1] == player && board[row - 2][col + 2] == player && board[row - 3][col + 3] == player) {
				return TRUE;
			}
		}
	}

	/* Tie condition check */
	for(uint8_t col = 0; col < NUM_COLS; col++) {
		if(!gameBoard[NUM_ROWS - COIN_GAME_LOGIC_OFFSET][col]) {
			return FALSE;
		}
	}
	gameOver = TRUE;
	return FALSE;
}


/* During human player turn, wait for touch screen input to select
 * where coin will drop. Between each input, redraw coin in position.
 * When button is pressed, coin will drop. This means we enable interrupts
 * for the button in this loop, then disable them if a coin can be placed.
 * */
void playTurn(void) {
	resetCoinPos();

	if(playerTurn == YELLOW) {
		LCD_Display_Coin((gameCoin.col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_YELLOW);
		__NVIC_EnableIRQ(BUTTON_IRQ_NUM);
		while(!coinDropped) {
			checkIfUserMovedCoin();
		}
	}

	else {
		LCD_Display_Coin((gameCoin.col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_RED);
		if(sessionGameMode == AI_MODE_SELECT) {
			utilityScore_t AIMove = alphaBeta(gameBoard, 0, MIN_SCORE, MAX_SCORE, 0, 0, RED, YELLOW);
			gameCoin.col = AIMove.col;
			if(canPlaceCoin(gameBoard, gameCoin.col)) {
				placeCoin(gameBoard, gameCoin.row, gameCoin.col);
				LCD_Display_Coin((gameCoin.col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, LCD_PIXEL_HEIGHT - BORDER_Y_OFFSET - (gameCoin.row + COIN_GAME_LOGIC_OFFSET) * BOARD_Y_OFFSET, LCD_COLOR_RED);
			}
			else {
				/* Debug */
			    LCD_Clear(0, LCD_COLOR_RED);
			}
		}
		else if(sessionGameMode == TWO_PLAYER_SELECT){
			__NVIC_EnableIRQ(BUTTON_IRQ_NUM);
			while(!coinDropped) {
				checkIfUserMovedCoin();
			}
		}
	}

	if(checkWinner(gameBoard, gameCoin.row, gameCoin.col, playerTurn)) {
		incrementWinCount();
	}

	playerTurn = (playerTurn % 2) + 1;
}


void playGame(void) {

	LCD_Draw_Board_Structure();
    HAL_TIM_Base_Start_IT(&htim2);
	while(!gameOver) {
		playTurn();
	}
    HAL_TIM_Base_Stop_IT(&htim2);
}


/*****************************************/
/*****************************************/
/********** AI FUNCTIONS START ***********/
/*****************************************/
/*****************************************/


int8_t getScoreOfPosition(uint8_t board[NUM_ROWS][NUM_COLS], uint8_t row, uint8_t col, uint8_t player) {
	int8_t score = 0;
	int8_t additionalScore = 0;

	/* Horizontal Scores */
	if((additionalScore = getScoreByDirection(board, row, col, 0, 1, player)) == 4) {
		return MAX_SCORE;
	}
	score += additionalScore;

	if((additionalScore = getScoreByDirection(board, row, col, 0, -1, player)) == 4) {
		return MAX_SCORE;
	}
	score += additionalScore;

	/* Vertical Score */
	if((additionalScore = getScoreByDirection(board, row, col, -1, 0, player)) == 4) {
		return MAX_SCORE;
	}
	score += additionalScore;

	/* Descending Diagonal Score */
	if((additionalScore = getScoreByDirection(board, row, col, 1, -1, player)) == 4) {
		return MAX_SCORE;
	}
	score += additionalScore;

	if((additionalScore = getScoreByDirection(board, row, col, -1, 1, player)) == 4) {
		return MAX_SCORE;
	}
	score += additionalScore;

	/* Ascending Diagonal Score */
	if((additionalScore = getScoreByDirection(board, row, col, 1, 1, player)) == 4) {
		return MAX_SCORE;
	}
	score += additionalScore;

	if((additionalScore = getScoreByDirection(board, row, col, -1, -1, player)) == 4) {
		return MAX_SCORE;
	}
	score += additionalScore;

	if(player == YELLOW) {
		score = -score;
	}

	/* Tie condition check */
	for(uint8_t col = 0; col < NUM_COLS; col++) {
		if(!gameBoard[NUM_ROWS - COIN_GAME_LOGIC_OFFSET][col]) {
			return score;
		}
	}

	return TIE_SCORE;
}


/* MiniMax algorithm with alpha-beta pruning. Maximizing player
 * will always be Red in this context, as that will be the AI.
 */
utilityScore_t alphaBeta(uint8_t board[NUM_ROWS][NUM_COLS], uint8_t depth, int8_t alpha, int8_t beta, uint8_t row, uint8_t col, uint8_t playerToMove, uint8_t prevPlayer) {

	utilityScore_t scoreAndMove = { .col = 0, .score = 0 };
	scoreAndMove.score = getScoreOfPosition(board, row, col, prevPlayer);

	/* Calculate utility of the terminal node in our minimax tree. */
	if(depth == MAX_DEPTH_SEARCH || scoreAndMove.score == MAX_SCORE || scoreAndMove.score == TIE_SCORE) {
		/* Player is maximizing, so just return the score calculated. */
		if(prevPlayer == RED) {

			return scoreAndMove;
		}

		/* Enemy player won, so set the weight heavily low. */
		if(scoreAndMove.score == MAX_SCORE) {

			scoreAndMove.score = MIN_SCORE;
		}

		return scoreAndMove;
	}

	/* If maximizing and not terminal, search for the maximum in this branch. */
	if(playerToMove == RED) {
		/* Set to min score possible to find max score of this branch */
		scoreAndMove.score = MIN_SCORE;
		uint8_t boardCopy[NUM_ROWS][NUM_COLS];

		for(int col = 0; col < NUM_COLS; col++) {
			if(canPlaceCoin(board, col)) {
				uint8_t row = gameCoin.row;
				memcpy(boardCopy, board, NUM_ROWS * NUM_COLS * sizeof(uint8_t));
				placeCoin(boardCopy, row, col);
				utilityScore_t branchScore = alphaBeta(boardCopy, depth + 1, alpha, beta, row, col, YELLOW, RED);

				if(branchScore.score > scoreAndMove.score) {
					scoreAndMove.score = branchScore.score;
					scoreAndMove.col = col;
					if(scoreAndMove.score > alpha) {
						alpha = scoreAndMove.score;
//						LCD_Clear(0, LCD_COLOR_WHITE);
//						LCD_DisplayChar(100, 70, 'M');
//						LCD_DisplayChar(120, 70, 'a');
//						LCD_DisplayChar(135, 70, 'x');
//						drawFromUnsignedInteger(100, 100, scoreAndMove.score);
//						HAL_Delay(1000);
					}
				}

				if(alpha >= beta) {
					break;
				}
			}
		}

		return scoreAndMove;
	}

	/* Else, minimizing score in this branch */
	else {
		/* Set to max score possible to find min score of this branch */
		scoreAndMove.score = MAX_SCORE;
		uint8_t boardCopy[NUM_ROWS][NUM_COLS];

		for(int col = 0; col < NUM_COLS; col++) {
			if(canPlaceCoin(board, col)) {
				uint8_t row = gameCoin.row;
				memcpy(boardCopy, board, NUM_ROWS * NUM_COLS * sizeof(uint8_t));
				placeCoin(boardCopy, row, col);
				utilityScore_t branchScore = alphaBeta(boardCopy, depth + 1, alpha, beta, row, col, RED, YELLOW);

				if(branchScore.score < scoreAndMove.score) {
					scoreAndMove.score = branchScore.score;
					scoreAndMove.col = col;
					if(scoreAndMove.score < beta) {
						beta = scoreAndMove.score;
//						LCD_Clear(0, LCD_COLOR_WHITE);
//						LCD_DisplayChar(100, 70, 'M');
//						LCD_DisplayChar(120, 70, 'i');
//						LCD_DisplayChar(135, 70, 'n');
//						drawFromUnsignedInteger(100, 100, scoreAndMove.score);
//						HAL_Delay(1000);
					}
				}

				if(beta <= alpha) {
					break;
				}
			}
		}
		return scoreAndMove;
	}

	return scoreAndMove;
}
