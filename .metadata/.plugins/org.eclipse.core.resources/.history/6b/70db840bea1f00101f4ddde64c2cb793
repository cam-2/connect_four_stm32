/*
 * ApplicationCode.c
 *
 *  Created on: Dec 30, 2023 (updated 11/12/2024) Thanks Donavon! 
 *      Author: Xavion
 *
 *  Edited on: April 17, 2025
 *  	Editor: Cameron Thomas
 */

#include "ApplicationCode.h"

/* Static variables */


extern void initialise_monitor_handles(void); 

static STMPE811_TouchData StaticTouchData;
extern coin_t gameCoin;
extern uint8_t coinDropped;

#if COMPILE_TOUCH_FUNCTIONS == 1
#endif // COMPILE_TOUCH_FUNCTIONS

void ApplicationInit(void)
{
	initialise_monitor_handles(); // Allows printf functionality
    LTCD__Init();
    LTCD_Layer_Init(0);
    LCD_Clear(0, LCD_COLOR_WHITE);
    LCD_Connect_Four_Init();

    #if COMPILE_TOUCH_FUNCTIONS == 1
	InitializeLCDTouch();

	// This is the orientation for the board to be directly up where the buttons are vertically above the screen
	// Top left would be low x value, high y value. Bottom right would be low x value, low y value.
	StaticTouchData.orientation = STMPE811_Orientation_Portrait_2;

	#endif // COMPILE_TOUCH_FUNCTIONS
}

void buttonInit(void) {

#if COMPILE_BUTTON_INTERRUPTS == 1
	button_Interrupt_Init();
#endif
	button_Init();

}

#if COMPILE_TOUCH_FUNCTIONS == 1

void checkIfTouchScreenPressed(void) {

	if(returnTouchStateAndLocation(&StaticTouchData) == STMPE811_State_Pressed) {
		/* The coordinates are inverted from the StaticTouchData struct,
		 * So we need to un-invert them when we pass it into our function to check which game button
		 * is pressed. In this case, the buttons are fairly centered so I ignored inverting the x-coordinate.
		 * */
		uint8_t gameMode = returnGameButtonPressed(StaticTouchData.x, LCD_PIXEL_HEIGHT - StaticTouchData.y);

		if(gameMode) {
			triggerGameButtonResponse(gameMode);
		}
	}
}

uint8_t returnGameButtonPressed(uint16_t xInput, uint16_t yInput) {

	if((xInput >= AI_BUTTON_X_LOWER && xInput <= AI_BUTTON_X_UPPER) && (yInput >= AI_BUTTON_Y_LOWER && yInput <= AI_BUTTON_Y_UPPER)) {
		return AI_MODE_SELECT;
	}

	else if((xInput >= TWO_PLAYER_BUTTON_X_LOWER && xInput <= TWO_PLAYER_BUTTON_X_UPPER) && (yInput >= TWO_PLAYER_BUTTON_Y_LOWER && yInput <= TWO_PLAYER_BUTTON_Y_UPPER)) {
		return TWO_PLAYER_SELECT;
	}

	return 0;
}

void triggerGameButtonResponse(uint8_t buttonMode) {

	if(buttonMode == AI_MODE_SELECT) {

		/* Provides an interactive feel when you press the game button.*/
		LCD_Draw_Game_Button(AI_BUTTON_X_LOWER, AI_BUTTON_X_UPPER - AI_BUTTON_X_LOWER, AI_BUTTON_Y_LOWER, AI_BUTTON_Y_UPPER - AI_BUTTON_Y_LOWER, LCD_COLOR_GREEN);
		HAL_Delay(750);
	    LCD_Clear(0, LCD_COLOR_WHITE);
		setGameMode(AI_MODE_SELECT);
		startNewGame();
	}

	else if(buttonMode == TWO_PLAYER_SELECT) {

		LCD_Draw_Game_Button(TWO_PLAYER_BUTTON_X_LOWER, TWO_PLAYER_BUTTON_X_UPPER - TWO_PLAYER_BUTTON_X_LOWER, TWO_PLAYER_BUTTON_Y_LOWER, TWO_PLAYER_BUTTON_Y_UPPER - TWO_PLAYER_BUTTON_Y_LOWER, LCD_COLOR_GREEN);
		HAL_Delay(750);
	    LCD_Clear(0, LCD_COLOR_WHITE);
		setGameMode(TWO_PLAYER_SELECT);
		startNewGame();
	}
}

#endif // COMPILE_TOUCH_FUNCTIONS

/* Game Functions */

void waitForUserResponse(void) {
	while(1) {
		#if COMPILE_TOUCH_FUNCTIONS == 1
		checkIfTouchScreenPressed();
		#endif
	}
}

void LCD_Display_Start_Screen(void) {

	LCD_Clear(0, LCD_COLOR_WHITE);
	displayStartScreen();
}

void LCD_Display_Stats_Screen(void) {

	LCD_Clear(0, LCD_COLOR_WHITE);
	HAL_Delay(750);
	displayStatsScreen();
}

void EXTI0_IRQHandler(void) {

	__NVIC_DisableIRQ(EXTI0_IRQn);

	// Drop Coin.

	__NVIC_ClearPendingIRQ(EXTI0_IRQn);
	clearPendingEXTI(GPIO_PIN_0);

}


