/*
 * GameLogic.C
 *
 *  Created on: Apr 17, 2025
 *      Author: Cameron Thomas
 */

#include "GameLogic.h"

static uint8_t sessionGameMode = 0;
static uint8_t playerTurn = 0;
static uint16_t yellowWinCount = 0;
static uint16_t redWinCount = 0;

static uint8_t gameBoard[CONNECT_FOUR_ROW_COUNT][CONNECT_FOUR_COLUMN_COUNT];

static STMPE811_TouchData StaticTouchData;
static coin_t gameCoin;

void setGameMode(uint8_t mode) {

	sessionGameMode = mode;
}

void placeCoin(uint8_t row, uint8_t column, uint8_t player) {

	gameBoard[row][column] = player;
	if(player == 0) {
		LCD_Display_Coin((row + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, LCD_PIXEL_HEIGHT - 5 - (column + COIN_GAME_LOGIC_OFFSET) * BOARD_Y_OFFSET, LCD_COLOR_YELLOW);
	}
	else {
		LCD_Display_Coin((row + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, LCD_PIXEL_HEIGHT - 5 - (column + COIN_GAME_LOGIC_OFFSET) * BOARD_Y_OFFSET, LCD_COLOR_RED);
	}
}

uint8_t checkIfCanPlaceCoin(uint8_t xPos, uint8_t player) {

	for(int i = 0; i < CONNECT_FOUR_ROW_COUNT; i++) {
		if(!gameBoard[xPos][i]) {
			placeCoin(xPos, i, player);
			playerTurn = playerTurn + 1 % 2;
			return 1;
		}
	}
	return 0;
}

void moveCoin(uint8_t xPos, uint8_t player) {
	clearFloatingCoin(gameCoin.xPos * BOARD_X_OFFSET, gameCoin.yPos);
	HAL_Delay(100);
	gameCoin.xPos = xPos;

	if(playerTurn == 0) {
		LCD_Display_Coin(gameCoin.xPos * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_YELLOW);
	}
	else {
		LCD_Display_Coin(gameCoin.xPos * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_RED);
	}
}

void checkIfUserMovedCoin(uint8_t player) {
	if(returnTouchStateAndLocation(&StaticTouchData) == STMPE811_State_Pressed) {
		HAL_Delay(200);
		/* Checks which side of the screen is pressed, as well as if we are still
		 * within the bounds of the board.
		 * */
		if(StaticTouchData.x > LCD_PIXEL_WIDTH / 2 && gameCoin.xPos > 1) {
			moveCoin(gameCoin.xPos - 1, player);
		}
		else if(StaticTouchData.x < LCD_PIXEL_WIDTH / 2 && gameCoin.xPos < 7) {
			moveCoin(gameCoin.xPos + 1, player);
		}
	}
}

void resetBoard(void) {

	memset(gameBoard, 0, sizeof(gameBoard));
}

void resetCoinPos(void) {

	gameCoin.xPos = COIN_DEFAULT_X;
	gameCoin.yPos = COIN_DEFAULT_Y;
}

void startNewGame(void) {

	resetBoard();
	playGame();
}

void playTurn(void) {

	if(playerTurn == 0) {
		/* Blueprint:
		 * Wait for touch screen input to select where coin will drop.
		 * Between each input, redraw coin in position.
		 * When button is pressed, coin will drop. This means we should probably enable interrupts
		 * for the button in this loop, then disable them.
		 * */
		LCD_Display_Coin(gameCoin.xPos * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_YELLOW);
		__NVIC_EnableIRQ(EXTI0_IRQn);
		while(playerTurn == 0) {
			checkIfUserMovedCoin(playerTurn);
		}
	}

	else {
		if(sessionGameMode == AI_MODE_SELECT) {
			; // To be determined if AI will use alpha-beta search or RNG.
		}
		else if(sessionGameMode == TWO_PLAYER_SELECT){
			LCD_Display_Coin(gameCoin.xPos * BOARD_X_OFFSET, gameCoin.yPos, LCD_COLOR_RED);
			__NVIC_EnableIRQ(EXTI0_IRQn);
			while(playerTurn == 1) {
				checkIfUserMovedCoin(playerTurn);
			}
		}
	}
}

uint8_t checkWinner(void) {
	yellowWinCount++;
	redWinCount++;
	return 0;
}

void playGame(void) {
	LCD_Draw_Board_Structure();
	resetCoinPos();

	while(1) {
		playTurn();
		if(checkWinner()) break;
	}
}


void EXTI0_IRQHandler(void) {

	__NVIC_DisableIRQ(EXTI0_IRQn);

	/* Drop Coin. The offset accounts for the logic used to draw the coin on the LCD display, which does not match
	 * the indices of the matrix that holds the data for the game board. */
	clearFloatingCoin(gameCoin.xPos * BOARD_X_OFFSET, gameCoin.yPos);
	if(checkIfCanPlaceCoin(gameCoin.xPos - COIN_GAME_LOGIC_OFFSET, playerTurn)) {
		__NVIC_ClearPendingIRQ(EXTI0_IRQn);
		clearPendingEXTI(BUTTON_PIN_NUM);
	}
	else {
		__NVIC_ClearPendingIRQ(EXTI0_IRQn);
		clearPendingEXTI(BUTTON_PIN_NUM);
		__NVIC_EnableIRQ(EXTI0_IRQn);
	}

}

