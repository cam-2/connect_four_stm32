/*
 * GameLogic.C
 *
 *  Created on: Apr 17, 2025
 *      Author: Cameron Thomas
 */

#include "GameLogic.h"

static uint8_t sessionGameMode = NO_MODE_SELECTED;
static uint8_t playerTurn = YELLOW;
static uint8_t gameOver = FALSE;
static uint8_t coinDropped = FALSE;

static uint8_t gameBoard[CONNECT_FOUR_ROW_COUNT][CONNECT_FOUR_COLUMN_COUNT];

static STMPE811_TouchData StaticTouchData;

extern TIM_HandleTypeDef htim2;

uint8_t yellowWinCount = 0;
uint8_t redWinCount = 0;
uint32_t numSecondsElapsedInGame = 0;
coin_t gameCoin;


void setGameMode(uint8_t mode) {
	sessionGameMode = mode;
}


void resetBoard(void) {
	memset(gameBoard, 0, sizeof(gameBoard));
}


void incrementWinCount(void) {

	if(playerTurn == YELLOW) {
		yellowWinCount++;
	}
	else {
		redWinCount++;
	}
	gameOver = TRUE;
}


void placeCoin(uint8_t col) {

	gameBoard[gameCoin.row][gameCoin.col] = playerTurn;
	coinDropped = TRUE;

	if(playerTurn == YELLOW) {
		LCD_Display_Coin((col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, LCD_PIXEL_HEIGHT - BORDER_Y_OFFSET - (row + COIN_GAME_LOGIC_OFFSET) * BOARD_Y_OFFSET, LCD_COLOR_YELLOW);
	}
	else {
		LCD_Display_Coin((col + COIN_GAME_LOGIC_OFFSET) * BOARD_X_OFFSET, LCD_PIXEL_HEIGHT - BORDER_Y_OFFSET - (row + COIN_GAME_LOGIC_OFFSET) * BOARD_Y_OFFSET, LCD_COLOR_RED);
	}
	return;

}


uint8_t checkIfCanPlaceCoin(uint8_t col) {

	for(int row = 0; row < CONNECT_FOUR_ROW_COUNT; row++) {
		if(!gameBoard[row][col]) {
			clearFloatingCoin(gameCoin.col * BOARD_X_OFFSET, gameCoin.row);
			gameCoin.col = col;
			gameCoin.row = row;
			return TRUE;
		}
	}
	return FALSE;
}


void moveCoin(uint8_t col) {
	clearFloatingCoin(gameCoin.col * BOARD_X_OFFSET, gameCoin.row);
	gameCoin.col = col;

	if(playerTurn == YELLOW) {
		LCD_Display_Coin(gameCoin.col * BOARD_X_OFFSET, gameCoin.row, LCD_COLOR_YELLOW);
	}
	else {
		LCD_Display_Coin(gameCoin.col * BOARD_X_OFFSET, gameCoin.row, LCD_COLOR_RED);
	}
}


void checkIfUserMovedCoin(void) {
	if(returnTouchStateAndLocation(&StaticTouchData) == STMPE811_State_Pressed) {
		HAL_Delay(200);
		/* Checks which side of the screen is pressed, as well as if we are still
		 * within the bounds of the board.
		 * */
		if(StaticTouchData.x > LCD_PIXEL_WIDTH / 2 && gameCoin.col > 1) {
			moveCoin(gameCoin.col - 1);
		}
		else if(StaticTouchData.x < LCD_PIXEL_WIDTH / 2 && gameCoin.col < 7) {
			moveCoin(gameCoin.col + 1);
		}
	}
}


void resetCoinPos(void) {
	gameCoin.col = COIN_DEFAULT_X;
	gameCoin.row = COIN_DEFAULT_Y;
	coinDropped = FALSE;
}


void startNewGame(void) {
	resetBoard();
	gameOver = FALSE;
    numSecondsElapsedInGame = 0;
	playGame();
}


/* During human player turn, wait for touch screen input to select
 * where coin will drop. Between each input, redraw coin in position.
 * When button is pressed, coin will drop. This means we enable interrupts
 * for the button in this loop, then disable them if a coin can be placed.
 * */
void playTurn(void) {
	resetCoinPos();

	if(playerTurn == YELLOW) {
		LCD_Display_Coin(gameCoin.col * BOARD_X_OFFSET, gameCoin.row, LCD_COLOR_YELLOW);
		__NVIC_EnableIRQ(EXTI0_IRQn);
		while(!coinDropped) {
			checkIfUserMovedCoin();
		}
		checkWinner(gameCoin.row, gameCoin.col, playerTurn);
	}

	else {
		LCD_Display_Coin(gameCoin.col * BOARD_X_OFFSET, gameCoin.row, LCD_COLOR_RED);
		if(sessionGameMode == AI_MODE_SELECT) {
			; // To be determined if AI will use alpha-beta search or RNG.
		}
		else if(sessionGameMode == TWO_PLAYER_SELECT){
			__NVIC_EnableIRQ(EXTI0_IRQn);
			while(!coinDropped) {
				checkIfUserMovedCoin();
			}
			checkWinner(gameCoin.row, gameCoin.col, playerTurn);
		}
	}
	playerTurn = (playerTurn % 2) + 1;
}

/* First check if theres a win condition by checking the last piece placed.
 * If no win condition, check for the case that a draw has occured,
 * (all pieces in column are full).
 * Otherwise, return false.
 */
void checkWinner(uint8_t row, uint8_t column, uint8_t player) {

	/* Horizontal check, left and right of coin placement. */
	if(checkWinnerByDirection(row, column, 0, 1, player) || checkWinnerByDirection(row, column, 0, -1, player)) return;

	/* Vertical check */
	if(checkWinnerByDirection(row, column, -1, 0, player)) return;

	/* Descending Diagonal check, from bottom and top of diagonal. */
	if(checkWinnerByDirection(row, column, 1, -1, player) || checkWinnerByDirection(row, column, -1, 1, player)) return;

	/* Ascending Diagonal check, from bottom and top of diagonal. */
	if(checkWinnerByDirection(row, column, 1, 1, player) || checkWinnerByDirection(row, column, -1, -1, player)) return;

	/* Tie condition check */
	for(uint8_t col = 0; col < CONNECT_FOUR_COLUMN_COUNT; col++) {
		if(!gameBoard[CONNECT_FOUR_ROW_COUNT - COIN_GAME_LOGIC_OFFSET][col]) {
			return;
		}
	}
	gameOver = TRUE;
	return;
}


uint8_t checkWinnerByDirection(uint8_t row, uint8_t col, uint8_t rowDelta, uint8_t colDelta, uint8_t player) {

    for (uint8_t count = 0; count < 4; count++) {
        if (row < CONNECT_FOUR_ROW_COUNT && row >= 0 && col < CONNECT_FOUR_COLUMN_COUNT && col >= 0) {
            if (gameBoard[row][col] != player) {
                return FALSE;
            }
        }
        else {
        	return FALSE;
        }
        row += rowDelta;
        col += colDelta;
    }
    incrementWinCount();
    return TRUE;
}


void playGame(void) {
	LCD_Draw_Board_Structure();
    HAL_TIM_Base_Start_IT(&htim2);
	while(!gameOver) {
		playTurn();
	}
    HAL_TIM_Base_Stop_IT(&htim2);
}
